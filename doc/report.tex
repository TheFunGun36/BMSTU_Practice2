\documentclass[a4paper, 14pt]{report} %размер бумаги устанавливаем А4, шрифт 12пунктов
\usepackage{extsizes}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}%включаем свою кодировку: koi8-r или utf8 в UNIX, cp1251 в Windows
\usepackage[english,russian]{babel}%используем русский и английский языки с переносами
\usepackage{amssymb,amsfonts,amsmath,mathtext,cite,enumerate,float} %подключаем нужные пакеты расширений
\usepackage[dvips]{graphicx} %хотим вставлять в диплом рисунки?
\usepackage{indentfirst}

\graphicspath{{./img/}}%путь к рисункам

\makeatletter
\renewcommand{\@biblabel}[1]{#1.} % Заменяем библиографию с квадратных скобок на точку:
\makeatother

\usepackage{geometry} % Меняем поля страницы
\geometry{left=2cm}% левое поле
\geometry{right=1.5cm}% правое поле
\geometry{top=1cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле

\usepackage[T1]{fontenc}
\usepackage{titlesec, blindtext, color}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter{.}\hsp}{0pt}{\Huge\bfseries}

\renewcommand{\theenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{.\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{.\arabic{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}% Меняем везде перечисления на цифра.цифра

\usepackage{setspace} % межстрочный интервал
\onehalfspacing

\bibliographystyle{unsrt}

\begin{document}
	\tableofcontents % это оглавление, которое генерируется автоматически
	\chapter{Введение}
	Кубик Рубика является очень простой головоломкой с точки зрения своего устройства. Но стоящая за ней математика проделала довольно долгий путь. Существуют нерешённые задачи, связанные с этой головоломкой.
	
	Сам по себе кубик Рубика, может выглядеть очень по-разному. В рамках данного курсового проекта будет рассмотрена одна из наиболее красивых и эффектных вариаций данной головоломки. 
	
	Целью курсового проекта является разработка программы построения и визуализации трёхмерной модели зеркального кубика Рубика на основе данных о вращении его граней. Для достижения поставленной цели необходимо решить следующие задачи:
	\begin{itemize}
		\item разработка способа формального представления кубика Рубика;
		\item анализ существующих алгоритмов удаления невидимых граней;
		\item реализация описанного алгоритма
		\item проектирование архитектуры программы
		\item разработка интерфейса программы
		\item разработка спроектированного ПО
	\end{itemize}

	\chapter{Аналитический раздел}
	\section{Кубик Рубика}
	\subsection{Описание кубика Рубика}
	Кубик Рубика (в честь Эрнё Рубика) – механическая головоломка, представляющая из себя куб, каждая грань которого делится малыми кубами на 9 частей (26 в сумме со всех сторон) \cite{how_to_assemble}. Каждая грань имеет уникальный цвет. Механизм, распологающийся в центре кубика, позволяет вращать каждую грань относительно кубика рубика. Таким образом, набор случайных поворотов граней приводит к «разборке» кубика рубика. Обратная «сборка» заключается в последовательности поворотов грани так, чтобы каждая грань кубика рубика снова стала одноцветной.
	
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{rubicks_cube}}
		\caption{Кубик Рубика}
		\label{rubicks_cube}
	\end{figure}

	\subsection{Формализация действий над кубиком Рубика}
	Для поворотов граней существуют некоторые обозначения. Пусть куб находится напротив наблюдателя. Тогда:
	
	\begin{itemize}
		\item F (front) – фронтальная грань. Находится непосредственно напротив наблюдателя.
		\item B (back) – задняя грань. Противоположная фронтальной.
		\item L (left) – левая грань. Находится по левую руку от наблюдателя.
		\item R (right) – правая грань. Находится по правую руку от наблюдателя.
		\item U (up) – верхняя грань.
		\item D (down) – нижняя грань.
	\end{itemize}

	Операции поворота грани по часовой стрелке обозначаются именем грани. Так, например, повернуть дважды фронтальную грань, затем повернуть по часовой стрелке верхнюю грань будет обозначаться так: FFU. Предусмотрено обозначение для поворота грани против часовой стрелки, для этого после символа обозначения грани добавляется апостроф. Так, например, поворот правой грани по часовой стрелке, затем поворот нижней грани против часовой стрелки, затем поворот правой грани по часовой стрелке обозначается так: RD’R.
	
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{cube_rotations}}
		\caption{способы поворота граней кубика Рубика}
		\label{cube_rotations}
	\end{figure}
	
	\subsection{Сборка кубика Рубика}
	Для сборки кубика Рубика не обязательно знать всю последовательность действий, применённую к нему, достаточно информации о цветах граней. На этой основе, можно применить, например, алгоритм Джессики Фридрих.
	
	Сборка кубика рубика, как правило, разбивается на четыре этапа:
	\begin{enumerate}
		\item Сборка «креста»
		\item Сборка первых двух слоёв (F2L)
		\item Ориентация кубиков верхнего слоя (OLL)
		\item Расстановка кубиков верхнего слоя (PLL)
	\end{enumerate}
	
	Каждый из этих этапов имеет конечное, относительно малое количество вариантов расположения цветов граней. Таким образом, решение очередного этапа кубика Рубика состоит в определении конкретной ситуации, и применение соответствующей последовательности действий. Так, например, во время сборки OLL может возникнуть ситуация, проиллюстрированая на рис. \ref{c_shape}. Её решением является следующая последовательность действий: R'U'R'FRF'UR
	
	\begin{figure}[ht]
		\center{\includegraphics[width=0.25\linewidth]{c_shape}}
		\caption{ситуация, которая может возникнуть во время сборки OLL}
		\label{c_shape}
	\end{figure}
		
	\subsection{Зеркальный кубик Рубика}
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{mirrored_rubics_cube}}
		\caption{внешний вид зеркального кубика Рубика в собранном (слева) и в разрбранном (справа) состояниях}
		\label{mirrored_cube}
	\end{figure}

	Цвет – не единственный способ обозначать правильно собранные грани. Популярной модификацией классического кубика Рубика является зеркальный кубик рубика. Основное отличие состоит в том, что его грани невозможно отличить по цвету, так как они все одноцветные. Вместо этого, малые параллелограммы, из которых состоит зеркальный кубик Рубика, отличаются друг от друга формой. Таким образом, грань собранного кубика Рубика состоит из граней параллелограммов разного размера, но остаётся квадратной формы. При разборке, форма куба теряется. Несмотря на эти различия, зеркальная и классическая версии кубика Рубика имеют общие принципы сборки.
	
	\begin{figure}[ht]
		\center{\includegraphics{mirrored_cube_propotions.png}}
		\caption{пропорции зеркального кубика Рубика}
		\label{fig:mirrored_cube_proportions}
	\end{figure}

	\section{Отрисовка сцены}
	Одной из основных задач разрабатываемого програмного продукта является отрисовка зеркального кубика Рубика. Рассмотрим существующие алгоритмы удаления невидимых граней:
	\begin{itemize}
		\item Алгоритм плавающего горизонта
		\item Алгоритм Варнока
		\item Алгоритм Робертса
		\item Алгоритм Вейлера – Азертона
		\item Алгоритм, Z-буфера
		\item Алгоритм, использующий список приоритетов
		\item Алгоритмы построчного сканирования
	\end{itemize}

	Все вышеперечисленные алгоритмы резко теряют эффективность, если среди объектов присутствует зеркальные поверхности, особенно если речь заходит о множественных отражениях. Вследствие этого, имеет смысл использовать алгоритм трассировки лучей.
	
	\subsection{Алгоритм прямой трассировки лучей}
	Основная идея алгоритма - промоделировать поведение света для получения реалистичного изображения. В реальном мире, свет исходит от источника света, отражается от отражающих поверхностей и рассеивается рассеивающими поверхностями. Некоторые лучи света попадают на сетчатку глаза, которая посылает сигнал об интенсивности и цвете пришедшего луча. Алгоритм, реализующий такую модель, называется алгоритмом прямой трассировки лучей.
	
	\subsection{Алгоритм обратной трассировки лучей}
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{backward_ray_trace}}
		\caption{обратная трассировка лучей}
		\label{backward_ray_trace}
	\end{figure}

	Заметим, что нас интересуют лишь те лучи света, которые попали на сетчатку глаза. На основе этого, при моделировании подобной системы, лучи можно пускать в обратную сторону, то есть начиная от сетчатки. Теперь цвет луча при столкновении будет рассчитываться в зависимости от освещённости очередной точки попадания луча и цвета поверхности, на которую попал луч.
	
	В качестве допущения, будем считать, что все поверхности на сцене являются непрозрачными.
	
	\subsection{Описание алгоритма обратной трассировки лучей}
	Алгоритму поступает следующие данные:
	\begin{itemize}
		\item местополжение наблюдателя;
		\item расстояние до проецирующей плоскости;
		\item местоположение и геометрия всех объектов на сцене.
	\end{itemize}

	На основе этих данных, алгоритм должен окрасить сетку пикселей $n\times m$ так, чтобы при отображении её на экране, можно было распознать реалистичное изображение.
	
	Для каждого пикселя, из камеры пускается луч в соответствующем направлении. При попадании луча в плоскость, порождается дополнительный луч, отражённый. Вектор отражения $\bar V_M$, при исходном луче $\bar V$, относительно нормали $\bar n$, при $|\bar n| = 1$ считается по следующей формуле:
	
	\begin{equation}
		\bar V_M = \bar V - 2\cdot\bar V \cdot\bar n\cdot\bar n
		\label{eq:bounce}
	\end{equation}

	Цвет данной точки рассчитывается как смешение цвета поверхности и цвета, рассчитаного при попадании луча $\bar V_M$ на поверхность.
	
	С целью упростить задачу поиска пересечения луча и поверхности, будем считать, что каждый объект сцены можно представить в виде набора из конечного числа треугольников.
	
	\section{Вывод по разделу}
	В аналитическом разделе был описан кубик Рубика, обозначения граней и их поворотов. Была объяснена разница между классическим кубиком Рубика и его вариацией - зеркальным кубиком Рубика.
	
	Так же, описана задача отрисовки трёхмерной сцены. Обозначена причина, по которой был выбран алгоритм обратной трассировки лучей в качестве способа отрисовки трёхмерной сцены.
	
	Были установлены ограничения по содержанию сцены, а именно:
	\begin{itemize}
		\item Все объекты на сцене являются непрозрачными
		\item Каждый объект сцены можно представить в виде конечного набора треугольников
	\end{itemize}
		
	\chapter{Конструкторский раздел}
	\section{Архитектура программы}
	\subsection{Сцена, объекты сцены}
	Проект является достаточно ёмким. Во время разработки, должна быть учтена возможность модификации программы, при этом в ней же присутствует высоконагруженный элемент - отрисовка сцены. Данным условиям удовлетворяет объектно-ориентированный подход к проектированию.
	
	Определим ключевые сущности, которые будут присутствовать в архитектуре сцены:
	\begin{itemize}
		\item Сцена. Должна агрегировать все объекты, которые могут находиться на сцене.
		\item Полигональная модель. Представляет собой набор из треугольников, каждый из которых содержит в себе все необходимые свойства поверхностей
		\item Камера. Представляет собой точку в пространстве, имеющую направление и область обзора.
		\item Кубик Рубика. Агрегирует 27 моделей малых параллелограммов, формирующих ранее описаный зеркальный кубик Рубика.
	\end{itemize}

	Добавив несколько вспомогательных классов, получим UML-диаграмму (см. рис. \ref{uml_scene}). Полученая диаграмма описывает некий домен сцены. Рассмотрим основные математические структуры:
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{uml_scene}}
		\caption{UML диаграмма классов сцены, без описания полей и методов}
		\label{uml_scene}
	\end{figure}
	
	\subsection{Математические структуры}
	Для описания положения объекта в пространстве, необходима следующая информация:
	\begin{itemize}
		\item позиция объекта,
		\item поворот объекта,
		\item размер объекта.
	\end{itemize}
	
	\subsubsection{Трёхмерный вектор}
	Трёхмерный вектор является тройкой действительных чисел $(x, y, z)$, каждая компонента которого является величиной проекции на соответствующую ось.
	
	Позиция объекта может быть описана радиус-вектором, описывающим смещение всех точек объекта относительно начала координат. Таким образом, достаточно прибавить данный радиус-вектор к каждой точке трёхмерной модели, чтобы получить её истинное положение.
	
	Используя точно такую же структуру, можно обозначить размер объекта. Каждый компонент вектора является коэффициентом масштабирования для каждой оси.
		
	\subsubsection{Кватернион}
	С поворотом объекта ситуация сильно сложнее. Использование тройки углов, описывающих последовательный поворот объекта вдоль всех осей, является очевидным путём, но он имеет свои недостатки:
	\begin{itemize}
		\item неоднозначность. Для любой последовательности вращений $A$, существует как минимум одна другая последовательность, приводящая объект к тому-же положению, что $A$;
		\item некорректный результат при последовательном применении двух и более троек углов поворота.
	\end{itemize}

	Вместо так называемых Эйлеровых углов, предпочтительнее использовать кватернионы\cite{quaternions}.
	
	Кватернион представляет собой кортеж из четырёх чисел $(q_0, q_1, q_2, q_3)$. Для каждого кватерниона $q$, существует обратный ему $q^{-1}\ne q$:
	\begin{equation}
		q^{-1}=(q_0, -q_1, -q_2, -q_3),
	\end{equation}
	
	исключением является единичный кватернион, определённый как $(1, 0, 0, 0)$. Он является обратным самому себе.
	
	Для кватернионов определена операция умножения. Пусть:
	\begin{equation}
			(t_0, t_1, t_2, t_3) = (r_0, r_1, r_2, r_3)\times(s_0, s_1, s_2, s_3).
	\end{equation}
	
	Тогда:
	\begin{subequations}
		\begin{align}
		t_0=(r_0\cdot s_0-r_1\cdot s_1-r_2\cdot s_2-r_3\cdot s_3) \\
		t_1=(r_0\cdot s_1+r_1\cdot s_0-r_2\cdot s_3+r_3\cdot s_2) \\
		t_2=(r_0\cdot s_2+r_1\cdot s_3+r_2\cdot s_0-r_3\cdot s_1) \\
		t_3=(r_0\cdot s_3-r_1\cdot s_2+r_2\cdot s_1+r_3\cdot s_0)
		\end{align}
	\end{subequations}
	
	С помощью кватерниона, можно повернуть точку в пространстве, заданную тремя координатами. Для этого нужно задать кватернион $p$, как:
	\begin{equation}
		p=(p_0,p_1,p_2,p_3)=(0, x, y, z),
	\end{equation}
	где $(x, y, z)$ - точка в пространстве. Получим $p'$ следующим образом:
	\begin{equation}
		p'=q^{-1}\cdot p\cdot q,
	\end{equation}
	где $q$ - кватернион, описывающий вращение. Искомая точка является тройкой $(p'_1, p'_2, p'_3)$.
	
	\subsubsection{Цвет}
	Структура цвета необходима для описания поверхностей объектов. Представляет собой тройку чисел $(r, g, b)$. Значение компонент определяет интенсивность цветов: красного, зелёного и синего соответственно. Сочетания этих трёх цветов разной интенсивности позволяют получить любой другой цвет.
	
	Определим операцию умножения цвета на скаляр:
	\begin{equation}
		C\cdot k=(r, g, b)\cdot k=(r\cdot k, g\cdot k, b\cdot k),
	\end{equation}
	где $C$ - исходный цвет, $k$ - скаляр.
	
	Определим операцию сложения цветов:
	\begin{equation}
		C_1+C_2=(r_1, g_1, b_1)+(r_2, g_2, b_2)=(r_1+r_2,g_1+g_2,b_1+b_2),
	\end{equation}
	где $C_1$ и $C_1$ - исходные цвета
	
	\subsubsection{Список математических структур}
	В конечном итоге, выделяем следующие структуры:
	\begin{itemize}
		\item Vector3D - трёхмерный вектор
		\item Quaternion - кватернион
		\item Transform - положение объекта в пространстве
		\item Color - цвет
	\end{itemize}
	
	\section{Алгоритм обратной трассировки лучей}
	Основная идея алгоритма трассировки лучей заключается в том, чтобы проследить путь, который проходит свет от источника до наблюдателя. Делается этот процесс в обратном направлении, то есть из точки наблюдателя выпускаются лучи, которые, несколько раз отражаются от встреченных поверхностей. Данный процесс продолжается до тех пор, пока либо количество дополнительно выпущеных лучей не превысит определённое значение, либо очередная поверхность не окажется неотражающей.
	
	\subsubsection{Алгоритм определения цвета пикселя}
	Алгоритм, определяющий цвет пикселя, принимает на вход два трёхмерных вектора: местонахождение наблюдателя (rs) и направление бросания луча (rd). Схема алгоритма представлена на рис. \ref{fig:calculate_pixel_color}
	\begin{figure}[!ht]
		\center{\includegraphics[width=1\linewidth]{calculate_pixel_color}}
		\caption{Схема алгоритма определения цвета пикселя}
		\label{fig:calculate_pixel_color}
	\end{figure}

	Переменная hits[] является массивом из структур, содержащих информацию о попадании. Они должны хранить следующие данные:
	\begin{itemize}
		\item было ли попадание (hit) – логическое;
		\item точке попадания луча (point) – трёхмерный вектор;
		\item направление отскока (bounce) – трёхмерный вектор;
		\item поверхность, с которой произошло пересечение (surface) – поверхность;
	\end{itemize}

	Структура поверхности содержит в себе информацию о треугольнике в пространстве и его свойствах, а именно:
	\begin{itemize}
		\item три точки, задающие треугольник (points) – тройка трёхмерных векторов;
		\item коэффициент рассеивания (diffuse) – вещественное. Является обратным к коэффициенту отражения;
		\item цвет поверхности (color) – цвет.;
		\item нормаль к поверхности (normal) – трёхмерный вектор;
		\item объект, частью которого является поверхность (owner) – объект сцены.;
	\end{itemize}
	
	Функция Blend реализует смешение двух цветов по формуле:
	\begin{equation}
		C = C_1\cdot k+C_2\cdot(1-k),
	\end{equation}
	где $C$, $C_1$, $C_2$ - цвета, $k\in[0, 1]$ - число.

	\subsubsection{Алгоритм бросания луча}
	Алгоритм бросания луча принимает на вход два трёхмерных вектора: местонахождение наблюдателя (rs) и направление бросания луча (rd). Схема алгоритма представлена на рис. \ref{fig:throw_ray}.
	
	\begin{figure}[!ht]
		\center{\includegraphics[width=1\linewidth]{throw_ray}}
		\caption{Схема алгоритма бросания луча}
		\label{fig:throw_ray}
	\end{figure}

	\subsubsection{Алгоритм поиска пересечения луча с треугольником}
	В качестве алгоритма поиска пересечения луча с треугольником используется алгоритм Моллера-Трумбора\cite{mollertrumbor}. Схема алгоритма представлена на рис. \ref{fig:triangle_intersec}
	\begin{figure}[!ht]
		\center{\includegraphics[width=1\linewidth]{triangle_intersec}}
		\caption{Схема алгоритма поиска пересечения луча с треугольником}
		\label{fig:triangle_intersec}
	\end{figure}

	Функция bounce выполняет отражение вектора $\bar V$ относительно нормали $\bar n$ в соответствии с формулой \ref{eq:bounce}
	\section{Зеркальный кубик Рубика}
	\subsection{Создание зеркального кубика Рубика}
	Создавать зеркальный кубик Рубика необходимо в соответствии с пропорциями, указанными на рис. \ref{fig:mirrored_cube_proportions}. Схема алгоритма создания параллелограммов представлена на рис \ref{fig:rubicks_create}.
	
	\begin{figure}[!ht]
		\center{\includegraphics[width=1\linewidth]{rubicks_create}}
		\caption{Схема алгоритма создания кубика рубика}
		\label{fig:rubicks_create}
	\end{figure}

	Данная схема не иллюстрирует использование пропорций, и отражает лишь порядок в котором должны создаваться параллелограммы.
	
	\subsection{Вращение зеркального кубика Рубика}
	
	Вращение грани производится в три этапа (порядок произвольный):
	\begin{enumerate}
		\item вращение моделей,
		\item смещение граней в массиве,
		\item смещение углов в массиве.
	\end{enumerate}

	Под углами и гранями подразумеваются угловые и граневые параллелограммы кубика Рубика.
	
	Смещение граней и углов в массиве выполняется как циклический сдвиг его элементов с соответствующей четвёркой индексов. В таблице \ref{tabular:cube_indexes} поставлены в соответствие какой циклический сдвиг нужно сделать при повороте соответствующей грани. Если вращение выполняется в противоположную сторону, достаточно развернуть последовательность индексов в другую сторону.
	
	\begin{table}[ht]
		\centering
		\caption{грани кубика Рубика и соответствующие им параллелограммы}
		\label{tabular:cube_indexes}
		\begin{tabular}{|c|c|c|}
			\hline
			Сторона & Индексы углов & Индексы граней \\
			\hline
			\hline
			F & 0, 6, 24, 18	& 3, 15, 21, 9		\\ \hline
			B & 8, 2, 20, 26	& 5, 11, 23, 17		\\ \hline
			L & 6, 8, 26, 24	& 7, 17, 25, 15		\\ \hline
			R & 2, 0, 18, 20	& 1, 9, 19, 11		\\ \hline
			U & 18, 24, 26, 20	& 21, 25, 23, 19	\\ \hline
			D & 0, 2, 8, 6		& 1, 5, 7, 3		\\ \hline
		\end{tabular}
	\end{table}
	
	\section{Вывод по разделу}
	В конструкторском разделе была описана архитектура создаваемой программы; выделены структуры, используемые в программе; ключевые алгоритмы, в числе которых отрисовка сцены методом трассировки лучей и вращение кубика Рубика. 
	
	\chapter{Технологический раздел}
	\section{Выбор используемых технологий}
	\subsection{Выбор ЯП}
	Основные два требования, которые предъявляются к языку программирования в рамках поставленной задачи:
	\begin{enumerate}
		\item высокая производительность;
		\item поддержка ООП.
	\end{enumerate}

	Всем вышеперечисленым требованиям отвечает язык С++ стандарта 20-го года.
	
	\subsection{Выбор фреймворка}
	Одно из ограничений курсовой работы - запрет на использование уже существующих решений для отрисовки трёхмерной сцены. Так как алгоритм будет разрабатываться самостоятельно, производительность не является основным критерием для выбора фреймворка. От него требуется возможность отрисовать на экране сетку пикселей. Так же фреймворк должен предоставлять средства разработки графического интерфейса.
	
	Всем вышеперечисленым требованиям удовлетворяет Qt, он и будет использоваться для создания интерфейса и отрисовки сетки пикселей на экране.
	
	\subsection{Выбор среды программирования}
	Qt creator - кроссплатформенная среда разработки, разработана специально для работы с фреймворком Qt. Несмотря на это, в качестве среды программирования (далее IDE) был использован Microsoft Visual Studio 2020. Таков выбор объясняется тем, что данная IDE:
	
	\begin{itemize}
		\item поддерживает систему решений, позволяющих разделять программуна множество связанных между собой проектов
		\item предоставляет средства профилирования, графически выделяющие строчки кода, занимающие большую долю процессорного времени
		\item предоставляет средства упрощённой работы с git
	\end{itemize}
	
	Таким образом, в качестве IDE используется Microsoft Visual Studio 2020
	
	\section{Интерфейс пользователя}
	Интерфейс программы представлен на рисунке \ref{fig:interface}.
	
	\begin{figure}[ht]
		\center{\includegraphics[width=1\linewidth]{interface}}
		\caption{интерфейс программы}
		\label{fig:interface}
	\end{figure}

	Справа находится окно просмотра. В нём отображается сцена после отрисовки. Основные элементы управления находятся слева.
	
	\subsection{Кнопки, флаги, поля}
	Кнопки U, L, F, R, D, B выполняют соответствующий поворот зеркального кубика Рубика, по отношению к изначальной позиции камеры. Флаг Пр. Ч. С. переключает кнопки U, L, F, R, D, B на U', L', F', R', D', B', функция которых меняется в соответствии с названием.
	
	Список поворотов - поле только для чтения, в которое записывается каждый совершённый поворот.
	
	Пикселей на луч - числовое поле, позволяющее установить габариты квадрата из пикселей, для которого будет пущен луч. Например, при значении 3, на каждый луч будет приходиться $3\times 3$ пикселей.
	
	Автоматическая отрисовка - флаг, при включении которого любое действие меняющее сцену или область отрисовки будет инициировать автоматическую перерисовку.
	
	Отрисовать - кнопка, инициирующая рендер сцены.
	
	\subsection{Меню}
	Меню Куб предоставляет действия:
	\begin{enumerate}
	\item Отменить поворот. Переводит куб в состояние, в котором он был до последней операции поворота грани
	\item В исходное состояние. Переводит куб с состояние, в котором он был при запуске программы
	\end{enumerate}

	Меню Сцена предоставляет действие Простая отрисовка. Переключает программу между режимами отрисовки сцены с использованием алгоритмов трассировки лучей и проецирования каркасной модели без удаления невидимых граней.
	
	Меню Камера предоставляею опцию В исходное состояние, которая возвращает камеру на позицию, где она была в момент запуска программы.
	
	Кроме того, в меню камера содержится подменю Повернуть... в котором перечислены 4 действия, смещающие камеру:
	\begin{enumerate}
		\item Влево
		\item Вправо
		\item Вверх
		\item Вниз
	\end{enumerate}

	\section{Тестирование}
	\subsection{Математические структуры}
	Для тестирования методов, работающих с математическими структурами, используется система автоматического тестирования Microsoft Visual Studio CPP Unit Test Framework. На рис. \ref{fig:test_code} представлен пример тестирующего класса.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=1\linewidth]{img/test_code}
		\caption{класс, реализующий тестирование методов для работы с трёхмерным вектором}
		\label{fig:test_code}
	\end{figure}
	
	Здесь TEST\_CLASS - группа тестов, соответствующая классу программы; TEST\_METHOD - метод, в котором прописаны тесты для соответствующего тестируемого метода класса.
	
	Visual Studio предоставляет инструмент для прогонки тестов, в виде окна Test Explorer. Его внешний вид представлен на рис \ref{fig:test_explorer}.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=1\linewidth]{img/test_explorer}
		\caption{окно Test Explorer}
		\label{fig:test_explorer}
	\end{figure}
	
	
	\subsection{Окно просмотра}
	Оценка правильности полученного изображения была проведена с помощью визуального анализа. В качестве вспомогательного инструмента, была реализована функция отображения сцены в каркасном виде без удаления граней. Внешний вид окна просмотра при работе этой функции представлен на рис. \ref{fig:scenecarcass}
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=0.7\linewidth]{img/scene_carcass}
		\caption{Окно просмотра в режиме простой отрисовки}
		\label{fig:scenecarcass}
	\end{figure}
	
	\subsection{Вывод по разделу}
	В технологическом разделе представлены все использованные программные средства с обоснованием их выбора. В частности - qt фреймворк. Показаны методы тестирования программы и описан интерфейс.
	
	%\chapter{Источники}	
	%https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html
	\bibliography{./sources}
\end{document}